Search in sorted matrix


approach 1

class Solution {
    public static boolean isinmatrix(int mid,int matrix[][]){
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                if(matrix[i][j]==mid){
                    return true;
                }
            }
        }
        return false;
    }
    public boolean searchMatrix(int[][] matrix, int target) {
        int low = Integer.MAX_VALUE;
        int high = Integer.MIN_VALUE;
        int n = matrix.length;
        int m = matrix[0].length;
        for(int i=0 ;i<n; i++){
            for(int j=0 ;j<m;j++){
                low = Math.min(low,matrix[i][j]);
                high = Math.max(high,matrix[i][j]);
            }
        }
        while(low<=high){
            int mid= low+(high-low)/2;
            if(mid == target && isinmatrix(mid,matrix)){
                return true;
            }
            else if(mid>target){
                high = mid-1;
            }
            else{
                low = mid+1;
            }
        }
        return false;
    }
}

approach 2

class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int n = matrix.length;
        int m = matrix[0].length;
        int low = 0;
        int high = n*m-1;
        while(low<=high){
            int mid = low+(high-low)/2;
            int row = mid/m;
            int col= mid%m;
            if(matrix[row][col] ==target){
                return true;
            }
            else if(matrix[row][col]>target){
                high = mid-1;
            }
            else{
                low = mid+1;
            }
        }   
        return false;
    }
}


2-- Spiral Matrix

class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int n = matrix.length;
        int m = matrix[0].length;
        int top=0;
        int left =0;
        int right = m-1;
        int bottom = n-1;
        List<Integer> list = new ArrayList<>();
        while(left<=right && top<=bottom){
            for(int i=left;i<=right;i++){
                list.add(matrix[top][i]);
            }   
            top++;
            for(int i=top;i<=bottom ;i++){
                list.add(matrix[i][right]);
            }
            right--;
            if(top<=bottom){
                for(int i=right ;i>=left ;i--){
                    list.add(matrix[bottom][i]);
                }
                bottom--;
            }
            if(left<=right){
                for(int i=bottom;i>=top;i--){
                    list.add(matrix[i][left]);
                }
                left++;
            }
        }
        return list;
    }
}

Number of Islands


class Solution {
    public static void dfs(char grid[][],int visited[][],int row,int col){
        int n = grid.length;
        int m = grid[0].length;
        int dr[] = {-1,0,1,0};
        int dc[] = {0,-1,0,1};
        for(int i=0;i<4;i++){
            int drow = row+dr[i];
            int dcol = col+dc[i];
            if(drow>=0 && drow<n && dcol>=0 && dcol<m && grid[drow][dcol]=='1' && visited[drow][dcol]!=1){
                visited[drow][dcol]=1;
                dfs(grid,visited,drow,dcol);
            }
        }
    }
    public int numIslands(char[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int visited[][] = new int[n][m];
        int count =0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]=='1' && visited[i][j]==0){
                    count++;
                    dfs(grid,visited,i,j);
                }
                else{
                    visited[i][j]=1;
                }
            }
        }
        return count;
    }
}
